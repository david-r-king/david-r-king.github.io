---
layout: essay
type: essay
title: "Software Engineering Reflection"
# All dates must be YYYY-MM-DD format!
date: 2025-12-15
published: true
labels:
  - Ethics in Software Engineering
  - Issue Driven Project Management
  - Functional Programming
  - App Development
---

<div class="essay-page se-reflection">
  <img
    src="../img/essays/SoftwareEngineering.png"
    class="essay-header-img"
    alt="coding"
  >
</div>

---

<div class="text-center">
  <h2> Reflecting on Software Engineering </h2>
</div>

This class introduced us to more detail of the process that comes with software engineering. Up to this point, the extent of our coding experience has been writing a program in an IDE to meet a submission date. This was the first class I have taken involving multiple pieces of technology, group projects, and common mothedologies. This exposure helped me learn how much more effort goes into large applications, far beyond writing the correct code to meet an objective. Specifically, this course helped me understand the importance of Agile Project Management, Configuration Management, and Design Patterns.

<div class="text-center">
  <h2> Agile Project Management and Issue-Driven Development </h2>
</div>

Project management is a common term I think most people can assume correctly. One particular type of project management we focused on in this course was Agile Project Management. This approach is useful in organizing and managing software projects by attempting to break large problems or work that needs to be done into small, incremental tasks that can be completed and implemented quickly. This format emphasizes flexibility, collaboration and continuous improvement.

Issue-Driven Project Management is what we used during our capstone group project. This consisted of clearly identifying a goal we had in mind, then breaking that into smaller, more digestible, goals and tracking them in a shared repository. These issues could represent a specific task, bug, feature or improvement. In doing this, everyone on the team had an overview of what still needs to be done and what others are currently working on. Our developers were able to select an issue to work on, create a branch off of our main repo, then submit and review changes through pull requests.

With this being the first group project I have been a part of, it easy to notice the benefits of this type of working environment. There was almost always very clear understanding in what the team as a whole needed to do and simple steps to take for continuous improvement. This mitigated the possibility of any one member of the team being confused, overwhelmed, or unsure in how to move forward. While we only had a few weeks of exercise in this space, it's fairly obvious how beneficial this kind of workflow is in the practical world of software engineering and development.

<div class="text-center">
  <h2> Configuration Management </h2>
</div>

Another major concept I learned is Configuration Management, which refers to the process of controlling changes to software over time. This includes tracking versions of code, managing branches, handling dependencies, and ensuring that development, testing, and production environments remain consistent.

Before this class, I underestimated how critical configuration management is. Through real experience, I learned how mismatches between database schemas, environment variables, or dependency versions can break an otherwise working application. For example, we encountered issues where code expected database fields that did not exist locally because migrations had not been applied correctly. Solving these problems required understanding tools like Git, Prisma migrations, and environment configuration files.

Configuration management is not limited to web development. Any long-term software system—such as operating systems, network infrastructure, or enterprise tools—relies on strict configuration control to prevent failures. This course showed me that writing code is only one part of engineering; maintaining consistency across systems is just as important.

<div class="text-center">
  <h2> Design Patterns </h2>
</div>

Design patterns are reusable solutions to common problems in software design. Rather than focusing on specific syntax or frameworks, design patterns describe proven ways to structure code so it is easier to understand, extend, and maintain.

During this course, I saw design patterns emerge naturally in our project. For example, separating server logic from client components, using shared utility functions, and centralizing data access through service files are all examples of design patterns. These patterns reduce duplication and make the codebase easier to modify without breaking unrelated parts of the system.

Design patterns apply to all areas of software engineering. Whether building a mobile app, a game engine, or a cloud service, engineers rely on patterns to manage complexity. Learning to recognize and apply these patterns helped me think more like an engineer rather than just a programmer.

<div class="text-center">
  <h2> Ethics in Software Engineering </h2>
</div>

Finally, this course reinforced the ethical responsibilities of software engineers. Ethics in software engineering involves considering how software affects users, organizations, and society. This includes protecting user data, avoiding deceptive design, ensuring accessibility, and being honest about system limitations.

Working on a real project made these concerns feel concrete. Decisions about authentication, permissions, and data visibility are not just technical choices—they impact privacy and trust. Even small mistakes can lead to security vulnerabilities or user harm. This awareness will influence how I approach future projects, especially those involving sensitive information.

---

<div class="text-center">
  <h4> Conclusion </h4>
</div>

Overall, this course taught me that software engineering is about much more than building web applications. Concepts like Agile Project Management, Configuration Management, and Design Patterns apply across all types of software systems. Through hands-on experience, I learned how engineering decisions affect not only functionality, but also reliability, collaboration, and ethics. These lessons will carry forward into any technical project I work on in the future, regardless of platform or programming language.
